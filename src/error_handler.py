import traceback
from datetime import datetime
from pathlib import Path
import json
import logging
import sys
import os

class ErrorHandler:
    def __init__(self):
        # Log dizinini olu≈ütur
        self.log_dir = Path("data")
        self.log_dir.mkdir(exist_ok=True)
        
        # Log dosyalarƒ±
        self.errors_file = self.log_dir / "errors.json"
        self.crash_file = self.log_dir / "crashes.log"
        self.debug_file = self.log_dir / "debug.log"
        
        # Logging ayarlarƒ±nƒ± yapƒ±landƒ±r
        logging.basicConfig(
            filename=self.debug_file,
            level=logging.DEBUG,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger('AICodeEditor')
        
        # Konsola da log g√∂nder
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.DEBUG)
        self.logger.addHandler(console_handler)
        
        # Hata listesini ba≈ülat/y√ºkle
        self.load_errors()
        
        # Global exception handler'ƒ± ayarla
        sys.excepthook = self.handle_uncaught_exception
        
    def load_errors(self):
        """Kayƒ±tlƒ± hatalarƒ± y√ºkle"""
        try:
            if self.errors_file.exists() and self.errors_file.stat().st_size > 0:
                with open(self.errors_file, 'r', encoding='utf-8') as f:
                    self.errors = json.load(f)
            else:
                # Dosya yoksa veya bo≈üsa yeni liste olu≈ütur
                self.errors = []
                # Bo≈ü JSON dosyasƒ± olu≈ütur
                self.save_errors()
        except json.JSONDecodeError:
            # JSON dosyasƒ± bozuksa yeni liste olu≈ütur
            self.logger.warning("Hata dosyasƒ± bozuk, yeni liste olu≈üturuluyor")
            self.errors = []
            self.save_errors()
        except Exception as e:
            self.logger.error(f"Hata dosyasƒ± y√ºklenirken beklenmeyen hata: {str(e)}")
            self.errors = []
            
    def save_errors(self):
        """Hatalarƒ± kaydet"""
        try:
            with open(self.errors_file, 'w', encoding='utf-8') as f:
                json.dump(self.errors, f, ensure_ascii=False, indent=2)
        except Exception as e:
            self.logger.error(f"Hatalar kaydedilirken hata olu≈ütu: {str(e)}")
            
    def handle_uncaught_exception(self, exc_type, exc_value, exc_traceback):
        """Yakalanmamƒ±≈ü hatalarƒ± yakala ve logla"""
        try:
            error_data = {
                'timestamp': datetime.now().isoformat(),
                'error_type': exc_type.__name__,
                'error_message': str(exc_value),
                'traceback': ''.join(traceback.format_tb(exc_traceback)),
                'command': 'UNCAUGHT_EXCEPTION',
                'context': 'Global Exception Handler',
                'stack_info': ''.join(traceback.format_stack())
            }
            
            # Hatayƒ± JSON dosyasƒ±na kaydet
            self.errors.append(error_data)
            self.save_errors()
            
            # Debug log'a yaz
            self.logger.error(
                f"Uncaught Exception:\nType: {exc_type.__name__}\n"
                f"Message: {str(exc_value)}\nTraceback:\n"
                f"{''.join(traceback.format_tb(exc_traceback))}"
            )
            
            # Crash log'a yaz
            with open(self.crash_file, 'a', encoding='utf-8') as f:
                f.write('\n' + '='*50 + '\n')
                f.write(f"CRASH REPORT - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"Type: {exc_type.__name__}\n")
                f.write(f"Message: {str(exc_value)}\n")
                f.write("Traceback:\n")
                f.write(''.join(traceback.format_tb(exc_traceback)))
                f.write("Stack Info:\n")
                f.write(error_data['stack_info'])
                f.write('\n' + '='*50 + '\n')
                
        except Exception as e:
            print(f"Error while logging error: {str(e)}")
            print(traceback.format_exc())
            
    def log_error(self, error: Exception, command: str = None, context: str = None):
        """Hatayƒ± kaydet"""
        try:
            error_data = {
                'timestamp': datetime.now().isoformat(),
                'error_type': type(error).__name__,
                'error_message': str(error),
                'traceback': traceback.format_exc(),
                'command': command or 'Unknown Command',
                'context': context or 'Unknown Context',
                'stack_info': ''.join(traceback.format_stack())
            }
            
            self.errors.append(error_data)
            self.save_errors()
            
            # Debug log'a yaz
            self.logger.error(
                f"Error in {context or 'Unknown Context'}:\n"
                f"Command: {command or 'Unknown Command'}\n"
                f"Type: {type(error).__name__}\n"
                f"Message: {str(error)}\n"
                f"Traceback:\n{traceback.format_exc()}"
            )
            
            # Kritik hatalarƒ± crash log'a da yaz
            if isinstance(error, (SystemError, RuntimeError, AttributeError, TypeError, KeyError)):
                with open(self.crash_file, 'a', encoding='utf-8') as f:
                    f.write('\n' + '='*50 + '\n')
                    f.write(f"ERROR REPORT - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                    f.write(f"Command: {command}\n")
                    f.write(f"Context: {context}\n")
                    f.write(f"Type: {type(error).__name__}\n")
                    f.write(f"Message: {str(error)}\n")
                    f.write("Traceback:\n")
                    f.write(traceback.format_exc())
                    f.write("Stack Info:\n")
                    f.write(error_data['stack_info'])
                    f.write('\n' + '='*50 + '\n')
                    
            return error_data
            
        except Exception as e:
            # Loglama sƒ±rasƒ±nda hata olu≈üursa bunu konsola yaz
            print(f"Error while logging error: {str(e)}")
            print(traceback.format_exc())
            return None
        
    def show_error_details(self, error_data: dict):
        """Hata detaylarƒ±nƒ± g√∂ster"""
        details = [
            "üîç Hata Detaylarƒ±:",
            f"Zaman: {datetime.fromisoformat(error_data['timestamp']).strftime('%Y-%m-%d %H:%M:%S')}",
            f"Tip: {error_data['error_type']}",
            f"Mesaj: {error_data['error_message']}",
            "\nKomut Bilgisi:",
            f"Komut: {error_data['command']}",
            f"Baƒülam: {error_data['context']}",
            "\nHata ƒ∞zleme:",
            error_data['traceback']
        ]
        
        # Hata detaylarƒ±nƒ± ge√ßici bir dosyaya yaz
        temp_file = Path("temp_error.txt")
        with open(temp_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(details))
            
        # VS Code'u a√ß
        try:
            subprocess.run(['code', str(temp_file)])
        except Exception:
            # VS Code a√ßƒ±lamazsa dosyayƒ± varsayƒ±lan metin edit√∂r√ºyle a√ß
            os.startfile(temp_file)

    def analyze_recent_errors(self) -> dict:
        """Son hatalarƒ± analiz et ve √∂zet √ßƒ±kar"""
        try:
            summary = {
                'total_errors': 0,
                'common_errors': {},
                'critical_errors': [],
                'last_error': None,
                'speech_errors': 0,
                'connection_errors': 0,
                'command_errors': 0
            }
            
            # Debug loglarƒ±nƒ± kontrol et
            if self.debug_file.exists():
                with open(self.debug_file, 'r', encoding='utf-8') as f:
                    logs = f.readlines()
                    for log in logs[-100:]:  # Son 100 log
                        if 'ERROR' in log:
                            summary['total_errors'] += 1
                            
                            # Konu≈üma hatalarƒ±
                            if 'SAPI.SpVoice' in log or 'speak' in log.lower():
                                summary['speech_errors'] += 1
                                
                            # Baƒülantƒ± hatalarƒ±    
                            if 'connection' in log.lower() or 'could not locate' in log.lower():
                                summary['connection_errors'] += 1
                                
                            # Komut hatalarƒ±
                            if 'command' in log.lower() or 'not understood' in log.lower():
                                summary['command_errors'] += 1
                                
                            # Son hatayƒ± kaydet
                            summary['last_error'] = log.strip()
            
            # Errors.json'ƒ± kontrol et
            if self.errors_file.exists():
                with open(self.errors_file, 'r', encoding='utf-8') as f:
                    error_data = json.load(f)
                    for error in error_data:
                        error_type = error.get('error_type', '')
                        if error_type in summary['common_errors']:
                            summary['common_errors'][error_type] += 1
                        else:
                            summary['common_errors'][error_type] = 1
                            
                        if error.get('is_critical', False):
                            summary['critical_errors'].append(error)
            
            return summary
            
        except Exception as e:
            self.logger.error(f"Hata analizi sƒ±rasƒ±nda hata: {str(e)}")
            return None
            
    def suggest_solutions(self, error_summary: dict) -> list:
        """Hata √∂zetine g√∂re √ß√∂z√ºm √∂nerileri sun"""
        solutions = []
        
        if error_summary['speech_errors'] > 0:
            solutions.append({
                'type': 'speech',
                'message': 'Ses motoru hatalarƒ± tespit edildi',
                'suggestions': [
                    'Windows SAPI5 ayarlarƒ±nƒ± kontrol edin',
                    'Alternatif TTS motoru pyttsx3 kullanƒ±labilir',
                    'T√ºrk√ße ses paketinin y√ºkl√º olduƒüundan emin olun'
                ]
            })
            
        if error_summary['connection_errors'] > 0:
            solutions.append({
                'type': 'connection',
                'message': 'Baƒülantƒ± hatalarƒ± tespit edildi',
                'suggestions': [
                    'ƒ∞nternet baƒülantƒ±nƒ±zƒ± kontrol edin',
                    'G√ºvenlik duvarƒ± ayarlarƒ±nƒ± kontrol edin',
                    'Chrome y√ºkl√º ve PATH\'te olduƒüundan emin olun'
                ]
            })
            
        if error_summary['command_errors'] > 0:
            solutions.append({
                'type': 'command',
                'message': 'Komut algƒ±lama hatalarƒ± tespit edildi',
                'suggestions': [
                    'Mikrofon ayarlarƒ±nƒ± kontrol edin',
                    'Ambient noise kalibrasyonunu tekrar yapƒ±n',
                    'Komut kelimelerini daha net s√∂yleyin'
                ]
            })
            
        return solutions

    def handle_error_with_analysis(self, error: Exception, command: str = "", context: str = "") -> tuple:
        """Hatayƒ± logla ve analiz et"""
        # √ñnce hatayƒ± normal ≈üekilde logla
        error_data = self.log_error(error, command, context)
        
        # Hata analizini yap
        error_summary = self.analyze_recent_errors()
        
        # √á√∂z√ºm √∂nerilerini al
        solutions = self.suggest_solutions(error_summary)
        
        return error_data, error_summary, solutions 